<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c_级数]]></title>
    <url>%2F2018%2F03%2F19%2Fc_%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[初步建立12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double fx(int x) //定义通项式&#123; double s; s=1/pow(x,2); //在此修改通项 return s;&#125;int main()&#123; int i=1;int b=10000;double t=0; cout&lt;&lt;&quot;请输入最后一项:&quot;; cin&gt;&gt;b; for(i;i&lt;=b;i++) t+=fx(i); cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;t; return 0;&#125; 效果还行,但是无法获得精度 改进加入精度变量，使输入可选为最后一项或精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double fx(int x) //定义通项式&#123; double s; s=1/pow(x,2); //在此修改通项 return s;&#125;bool ju() //区分计算类型&#123; int a; cout&lt;&lt;&quot;请选择计算模式。\n&quot;; cout&lt;&lt;&quot;1.输入精度\n&quot;; cout&lt;&lt;&quot;2.输入最后一项\n&quot;; cout&lt;&lt;&quot;____\b&quot;; cin&gt;&gt;a; if(a==1) return 0; else if(a==2) return 1; else cout&lt;&lt;&quot;请输入1或2&quot;; return ju();&#125;double mod1() //精度计算模式&#123; double q=0.01;int i=1;double t=0; cout&lt;&lt;&quot;请输入精度：&quot;; cin&gt;&gt;q; for(i;fx(i)&gt;=q;i++) t+=fx(i); return t;&#125;double mod2() //最后一项计算模式&#123; int i=1;int b=10000;double t=0; cout&lt;&lt;&quot;请输入最后一项:&quot;; cin&gt;&gt;b; for(i;i&lt;=b;i++) t+=fx(i); return t;&#125;int main()&#123; double t; if(ju()) t=mod2(); else t=mod1(); cout&lt;&lt;&quot;所求为：&quot;&lt;&lt;t&lt;&lt;endl; return 0;&#125; 完美运行！问题又来了，如何通项改变了怎么办，能不能输入通项呢？这与求定积分那个的问题类似，最后都归结为：如何解析输入的表达式未完]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py_requests简单爬取]]></title>
    <url>%2F2018%2F03%2F18%2Fpy_requests%E7%AE%80%E5%8D%95%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[学习使用requests模块爬取简单网页 首先安装requests模块pip install requests 初步建立12345import requestsurl = input(&quot;请输入地址：&quot;)r = requests.get(url)requests.encoding=&apos;utf-8&apos;print(r.text) 效果还行]]></content>
      <tags>
        <tag>py</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c_定积分]]></title>
    <url>%2F2018%2F03%2F17%2Fc_%E5%AE%9A%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[求定积分近似值初步建立#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) cout&lt;&lt;&quot;所求积分为:&quot;&lt;&lt;gx(a,b,n)&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分为:&quot;&lt;&lt;-gx(b,a,n)&lt;&lt;endl; return 0; } 由于使用过剩近似值代替，误差较大，应做出改进 改进近似值#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; } double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b,过剩 { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); s*=l; return s; } double hx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b，不足 { int i=0;double l=(b-a)/n;double s=0; for(i;i&lt;n;i++) s+=fx(a+i*l); s*=l; return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; return 0; } 尚不能比较两近似值大小 改进：比较近似值大小#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; } double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b,过剩 { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); s*=l; return s; } double hx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b，不足 { int i=0;double l=(b-a)/n;double s=0; for(i;i&lt;n;i++) s+=fx(a+i*l); s*=l; return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) { if(hx(a,b,n)&lt;gx(a,b,n)) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; } else { if(hx(b,a,n)&gt;gx(b,a,n)) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; } return 0; } 尚不能修改被积函数 未完]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
</search>
