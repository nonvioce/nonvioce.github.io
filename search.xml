<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[先来一首诗。 相见时难别亦难，东风无力百花残。春蚕到死丝方尽，蜡炬成灰泪始干。晓镜但愁云鬓改，夜吟应觉月光寒。蓬山此去无多路，青鸟殷勤为探看。 不只为何，总感觉此时此景与此诗非常般配。 回一回头 两年前的今天，坐在教室里刷着题，胡思乱想的一些不该想的东西，期待着一周后的“高考节”——放假两三天。此时，意气风发，心中有着自己的理想。 去年今日，漫不经心的拿起一份试卷，随便扫一眼，感觉差不多会了，会的跳过，不会的做一下，好了，下一份。有面临大敌的激动，也有结束“苦难”的期待，还有对即将来临的考试结果的云淡风轻，更有临别惜别的伤感。 今天，闹钟响了几次还是没有起床，一直到快要迟到才起床。急匆匆地去吃了早点，踩着时间点去上课。上课干什么呢？睡觉，玩手机。 一些难以言表的事勾起了这样的回忆。不回忆就不会伤感，也许就是这样的。好啦，胡说八道多了不好。说两正事吧。 高考加油 “2018年的地球为你们而转动”！真的，很严肃。这话说给谁听自己心里有数，无论看到与否说了就好。不会说话，总之不要在意便是。 好久没更 先来波检讨。这个……只能说确实忙。定时无法保证质量，还是不定时吧。有时间来写写，自己读读就好。 随意评论，随意回复。]]></content>
      <categories>
        <category>杂草</category>
      </categories>
      <tags>
        <tag>杂草</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入坑js]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%85%A5%E5%9D%91js%2F</url>
    <content type="text"><![CDATA[好久没来了，博主最近入坑JavaScript了，感觉和C有些像。 永远的开头hello,world1document.write(&quot;hello,world&quot;) 另外，在js里弹窗很容易写。1alert(&quot;helo,world&quot;) js主要还是嵌入HTML中啦，对于学爬虫大有好处，所以才入的坑。]]></content>
      <categories>
        <category>爬虫</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于app]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%85%B3%E4%BA%8Eapp%2F</url>
    <content type="text"><![CDATA[好久没更啦，博主最近有点忙。忽然发现小伙伴们都对做app有兴趣，其实呢写android的app不一定就要用java语言的，这里就介绍一下下面几种方法不用java写app。 网页转app 其实呢，严格来说这个并不算写app啦。原理就是利用第三方软件将网页打包成app。会HTML的小伙伴可以自己购买一个域名发布一个网页然后打包，虽然很显然这样是浪费。当然我们也可以打包别人的网页啦，比如打包这个http://www.windows93.net,效果还是很好的，这样的目的呢只能是方便啦。 关于这种第三方软件呢，推荐一个app，Fusion App,酷安https://www.coolapk.com能够找到。至于怎么用呢，看作者的教程吧。 用C++写 其实用C++写也是可以的，不过我们不能用原来的编译器了。看这个吧http://www.cocoachina.com/bbs/read.php?tid=333937，当然，也有别的，比比如有个app叫AIDE也能做到。不过博主都不喜欢，因为还有一种方法更好。 用python写 超级语言就是有优势，python有一个第三方库kivy，可以实现这一点。官网https://kivy.org/。具体怎么用，博主也只是入门，就不介绍了。 如果这还不能满足你，老老实实学java吧。]]></content>
      <categories>
        <category>杂乱的知识</category>
        <category>app</category>
      </categories>
      <tags>
        <tag>py</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py_sympy高等数学表达式的计算]]></title>
    <url>%2F2018%2F03%2F25%2Fpy-sympy%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[本来在研究如何用迭代法解任意方程，不料发现了一个强大的数学工具——sympy。官网 http://www.sympy.org 首先安装这个看官网啦，博主是这样安装的： pip install sympy 使用博主也在学习，这里举几个常用的 解方程举个例子吧1234from sympy import symbolsfrom sympy import solvex = symbol(&apos;x&apos;)solve(x**2 - 2, x) 这样就解出来了，当然啦，还有更详细的用法，这里就不介绍了。 求导diff 积分integrate是不是不过瘾呢？这里先综述一下，以后再细细介绍。]]></content>
      <categories>
        <category>数学工具</category>
        <category>py</category>
      </categories>
      <tags>
        <tag>py</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于位运算]]></title>
    <url>%2F2018%2F03%2F23%2F%E5%85%B3%E4%BA%8E%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[几个按位运算符（c++)（本文不考虑‘～’运算）因为按位运算是一位一位的算，所以先考虑其任意一位即可。比如：10010&amp;01011，我们人类计算时一般就会从左往右一位位的算，先算1&amp;&amp;0=0,然后0&amp;&amp;1=0,然后0&amp;&amp;0=0,然后1&amp;&amp;1=1,然后0&amp;&amp;1=0,所以得00010。所以，下文就先考虑其中任意一位产生的效果。假设有数a，与另一个数b进行运算，考虑其中任意一位： 先看&amp;（都为1时结果为1）如果b的这一位是0,那么 如果a的这位是0,这位的结果为0; 如果a的这位是1,这位的结果为0;总之，无论如何都是0,为了方便书写，我们暂且记做?&amp;0=0（用问号表示与0运算的那个数）这样写是不对的如果b的这一位是1,那么 如果a的这位是0,这位的结果为0; 如果a的这位是1,这位的结果为1;总之，无论如何都不变,为了方便书写，我们暂且记做？&amp;0，？不变这样写是不对的再看|（有一个为1结果为1）同理有：？|0,？不变？|1=1 还有^（不一样时结果为1）同理有：？^1,？取反（1变成0,0变成1）？^0,？不变拿到一起 &amp;0,0 &amp;1,不变 |0,不变 |1,1 ^1,取反 ^0,不变解决问题直接举个例子：现有一个8位二进制的整数a，请你通过位运算使前四位不变，五六位取反，第七位变为1,第八位变为0。我们是正常人，不妨就从左往右算： 前四位不变，先不管 五六位取反，考虑^1,那么运算应该是a^_ _ _ _ 1 1 _ _,如何填入剩下的呢？都是0,让其不变。所以第一步运算为a^00001100 然后第七位变为1,考虑|1,也就是用第一步运算结果|_ _ _ _ _ _ 1 _,为了使剩下的不变，别的都取0。式子变为（a^00001100)|00000010 然后第8位变为0,考虑&amp;0，也就是用第二步运算结果&amp;_ _ _ _ _ _ _ 0,为了使剩下的不变，别的都取1。式子变为（（a^00001100)|00000010）&amp;11111110 不想用括号，按位运算是左结合的，把式子变为11111110&amp;00000010|00001100^aOK,大功告成，这样得出的结果不一定是最简单的，但是比较容易想。]]></content>
      <categories>
        <category>杂乱的知识</category>
        <category>运算</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c_级数]]></title>
    <url>%2F2018%2F03%2F22%2Fc_%E7%BA%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[初步建立12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double fx(int x) //定义通项式&#123; double s; s=1/pow(x,2); //在此修改通项 return s;&#125;int main()&#123; int i=1;int b=10000;double t=0; cout&lt;&lt;&quot;请输入最后一项:&quot;; cin&gt;&gt;b; for(i;i&lt;=b;i++) t+=fx(i); cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;t; return 0;&#125; 效果还行,但是无法获得精度 改进加入精度变量，使输入可选为最后一项或精度1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double fx(int x) //定义通项式&#123; double s; s=1/pow(x,2); //在此修改通项 return s;&#125;bool ju() //区分计算类型&#123; int a; cout&lt;&lt;&quot;请选择计算模式。\n&quot;; cout&lt;&lt;&quot;1.输入精度\n&quot;; cout&lt;&lt;&quot;2.输入最后一项\n&quot;; cout&lt;&lt;&quot;____\b&quot;; cin&gt;&gt;a; if(a==1) return 0; else if(a==2) return 1; else cout&lt;&lt;&quot;请输入1或2&quot;; return ju();&#125;double mod1() //精度计算模式&#123; double q=0.01;int i=1;double t=0; cout&lt;&lt;&quot;请输入精度：&quot;; cin&gt;&gt;q; for(i;fx(i)&gt;=q;i++) t+=fx(i); return t;&#125;double mod2() //最后一项计算模式&#123; int i=1;int b=10000;double t=0; cout&lt;&lt;&quot;请输入最后一项:&quot;; cin&gt;&gt;b; for(i;i&lt;=b;i++) t+=fx(i); return t;&#125;int main()&#123; double t; if(ju()) t=mod2(); else t=mod1(); cout&lt;&lt;&quot;所求为：&quot;&lt;&lt;t&lt;&lt;endl; return 0;&#125; 完美运行！问题又来了，如何通项改变了怎么办，能不能输入通项呢？这与求定积分那个的问题类似，最后都归结为：如何解析输入的表达式未完]]></content>
      <categories>
        <category>数学工具</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于解析数学表达式的一点构想]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%85%B3%E4%BA%8E%E8%A7%A3%E6%9E%90%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%80%E7%82%B9%E6%9E%84%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前面两篇留下了一个解析数学表达式的问题。有时不得不说c语言不适合数学建模，解析数学表达式变成一大难题。下面给出解决方案。 方案一：利用python如果这个程序用python来编，那么一定会非常愉快的，因为有个强大的函数eval()。所以不妨用python来编，然后嵌入c++。python接口：1234#解析数学表达式def fx(): a = input(&quot;请输入表达式：&quot;) return eval(a) 嵌入c后：1234567891011121314#include &quot;stdafx.h&quot;#include &quot;Python.h&quot;#include &lt;iostream&gt;using namespace std;int _tmain(int argc, _TCHAR* argv[])&#123; cin&gt;&gt;a Py_Initialize(); PyRun_SimpleString(&quot;print(eval(a)) &quot;); //输入的python命令 Py_Finalize(); getchar(); return 0;&#125; 这样就实现了在c中嵌入python并将表达式计算的过程。类比这个，前面级数和不定积分中的输入表达式就不能实现，在此不赘述。其实，前面的两个程序用python很容易实现，例如1234567891011#求级数import matha = input(&quot;请输入通项式&quot;)def ax(x): s = eval(a) return sb = int(input(&quot;请输入最后一个值:&quot;))s =0for i in range(1,b): s += ax(i)print(&quot;级数为 &#123;&#125;&quot;.format(s)) 在此不做之前的优化，只为说明eval()函数的实用性。 方案二：自己用写一个eval()函数emmmm,这个博主仍在努力]]></content>
      <categories>
        <category>数学工具</category>
        <category>c+py</category>
      </categories>
      <tags>
        <tag>py</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[py_requests简单爬取]]></title>
    <url>%2F2018%2F03%2F18%2Fpy_requests%E7%AE%80%E5%8D%95%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[学习使用requests模块爬取简单网页 首先安装requests模块pip install requests 初步建立12345import requestsurl = input(&quot;请输入地址：&quot;)r = requests.get(url)requests.encoding=&apos;utf-8&apos;print(r.text) 效果还行]]></content>
      <categories>
        <category>爬虫</category>
        <category>py</category>
      </categories>
      <tags>
        <tag>py</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c_定积分]]></title>
    <url>%2F2018%2F03%2F17%2Fc_%E5%AE%9A%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[求定积分近似值初步建立#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) cout&lt;&lt;&quot;所求积分为:&quot;&lt;&lt;gx(a,b,n)&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分为:&quot;&lt;&lt;-gx(b,a,n)&lt;&lt;endl; return 0; } 由于使用过剩近似值代替，误差较大，应做出改进 改进近似值#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; } double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b,过剩 { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); s*=l; return s; } double hx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b，不足 { int i=0;double l=(b-a)/n;double s=0; for(i;i&lt;n;i++) s+=fx(a+i*l); s*=l; return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; return 0; } 尚不能比较两近似值大小 改进：比较近似值大小#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double fx(double x=0) //定义被积函数 { double s; s=pow(2,x); //在此修改函数 return s; } double gx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b,过剩 { int i=1;double l=(b-a)/n;double s=0; for(i;i&lt;=n;i++) s+=fx(a+i*l); s*=l; return s; } double hx(double a=0,double b=0,int n=1) //定义简单积分，先默认a&lt;=b，不足 { int i=0;double l=(b-a)/n;double s=0; for(i;i&lt;n;i++) s+=fx(a+i*l); s*=l; return s; } int main() //加入防错系统 { double a=0;double b=0;int n=1; cout&lt;&lt;&quot;请输入积分下限，上限，分割份数:&quot;; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; if(a&lt;=b) { if(hx(a,b,n)&lt;gx(a,b,n)) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;gx(a,b,n)&lt;&lt;&quot;到 &quot;&lt;&lt;hx(a,b,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;(hx(a,b,n)+gx(a,b,n))/2&lt;&lt;endl; } else { if(hx(b,a,n)&gt;gx(b,a,n)) cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; else cout&lt;&lt;&quot;所求积分在 &quot;&lt;&lt;-gx(b,a,n)&lt;&lt;&quot;到 &quot;&lt;&lt;-hx(b,a,n)&lt;&lt;&quot;之间,平均值为 &quot;&lt;&lt;-(hx(b,a,n)+gx(b,a,n))/2&lt;&lt;endl; } return 0; } 尚不能修改被积函数 未完]]></content>
      <categories>
        <category>数学工具</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
</search>
